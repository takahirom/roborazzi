import java.util.regex.Matcher
import java.util.regex.Pattern

plugins {
  id 'com.android.application' version libs.versions.agp apply false
  id 'com.android.library' version libs.versions.agp apply false
  id 'org.jetbrains.kotlin.multiplatform' version libs.versions.kotlin apply false
  id 'org.jetbrains.compose' version libs.versions.composeMultiplatform apply false
  id 'de.mannodermaus.android-junit5' version libs.versions.junit5Android apply false
  id 'tech.apter.junit5.jupiter.robolectric-extension-gradle-plugin' version libs.versions.junit5Robolectric apply false

  id 'org.jetbrains.kotlin.android' version libs.versions.kotlin apply false
  id "com.vanniktech.maven.publish" version libs.versions.mavenPublish apply false
  // Just for Gradle Build, included build will be applied
  id("io.github.takahirom.roborazzi") version "1.0.0" apply false
}

allprojects {
  // Apply the same Java compatibility for each module
  def javaVersion = libs.versions.javaTarget.get()
  def toolchainVersion = libs.versions.javaToolchain.get()

  def javaTargetVersion = JavaVersion.toVersion(javaVersion)
  def jvmTargetVersion = org.jetbrains.kotlin.gradle.dsl.JvmTarget.@Companion.fromTarget(javaVersion)

  plugins.withId("java") {
    java {
      toolchain {
        languageVersion.set(JavaLanguageVersion.of(toolchainVersion))
      }
    }
  }

  plugins.withType(com.android.build.gradle.BasePlugin).configureEach {
    android {
      compileOptions {
        sourceCompatibility javaTargetVersion
        targetCompatibility javaTargetVersion
      }
    }
  }

  tasks.withType(org.gradle.api.tasks.compile.JavaCompile).configureEach {
    sourceCompatibility = javaTargetVersion
    targetCompatibility = javaTargetVersion
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
    compilerOptions {
      jvmTarget.set(jvmTargetVersion)

      freeCompilerArgs.addAll(
        "-Xopt-in=com.github.takahirom.roborazzi.InternalRoborazziApi",
        "-Xopt-in=com.github.takahirom.roborazzi.ExperimentalRoborazziApi",
      )
    }
  }

  plugins.withId('com.vanniktech.maven.publish') {
    project.group = "io.github.takahirom.roborazzi"
    mavenPublishing {
      publishToMavenCentral(com.vanniktech.maven.publish.SonatypeHost.S01)
      signAllPublications()
    }

    plugins.withId('maven-publish') {
      publishing {
        repositories {
          maven {
            name = "LocalMaven"
            url = file("${rootProject.buildDir}/localMaven").toURI().toString()
          }
          def internalUrl = providers.gradleProperty("internalUrl")
          if (internalUrl.isPresent()) {
            maven {
              name = "internal"
              url = internalUrl
              credentials {
                username = providers.gradleProperty("internalUsername").get()
                password = providers.gradleProperty("internalPassword").get()
              }
            }
          }
        }
      }
    }
  }
}

class Topic {
    String name
    String content

    @Override
    String toString() {
        return "Topic(name: $name, content: ...)"
    }
}

def topicsPath = "docs/topics"
def topicsDir = rootProject.file(topicsPath)
def readmeTemplate = rootProject.file("README.template.md")
def readme = rootProject.file("README.md")
// Generate README.md from docs/topics/topic_name.md files by coping
// Insert topics into <topics=name="...">...</topics> by name in README.md
tasks.register("generateReadme") {
    doLast {
        def readmeContent = readmeTemplate.text
        def topicFiles = []
        topicsDir.eachFileRecurse { file ->
            if (file.name.endsWith(".md")) {
                topicFiles.add(file)
            }
        }
        def topics = topicFiles.collect { file ->
            def name = file.name.substring(0, file.name.length() - ".md".length())
            def content = Matcher.quoteReplacement(file.text)
            new Topic(name: name, content: content)
        }
        def newReadmeContent = readmeContent
        println(topics)
        topics.forEach { topic ->
            def pattern = Pattern.compile("<div name=\"topic_${topic.name}\">.*?</div>", Pattern.DOTALL)
            def result = pattern.matcher(newReadmeContent).find()
            println("topic: $topic pattern: $pattern result: $result")

            def generatedComment = "<!-- Generated by $topicsPath/${topic.name}.md. Do not edit this file. -->"
            def newTopicContent = "<div name=\"topic_${topic.name}\">\n\n$generatedComment\n${topic.content}\n<\\/div>"
            newReadmeContent = pattern.matcher(newReadmeContent)
                    .replaceAll(newTopicContent)
        }
        readme.write(newReadmeContent)
    }
}