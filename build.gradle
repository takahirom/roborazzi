import java.util.regex.Matcher
import java.util.regex.Pattern

plugins {
  id 'com.android.application' version libs.versions.agp apply false
  id 'com.android.library' version libs.versions.agp apply false
  id 'org.jetbrains.kotlin.multiplatform' version libs.versions.kotlin apply false
  id 'org.jetbrains.compose' version libs.versions.composeMultiplatform apply false

  id 'org.jetbrains.kotlin.android' version libs.versions.kotlin apply false
  id "com.vanniktech.maven.publish" version libs.versions.mavenPublish apply false
  // Just for Gradle Build, included build will be applied
  id("io.github.takahirom.roborazzi") version "1.0.0" apply false
}

allprojects {
  // Apply the same Java compatibility for each module
  def javaVersion = libs.versions.javaTarget.get()
  def toolchainVersion = libs.versions.javaToolchain.get()

  def javaTargetVersion = JavaVersion.toVersion(javaVersion)
  def jvmTargetVersion = org.jetbrains.kotlin.gradle.dsl.JvmTarget.@Companion.fromTarget(javaVersion)

    plugins.withId("java") {
    java {
      toolchain {
        languageVersion.set(JavaLanguageVersion.of(toolchainVersion))
      }
    }
  }

  plugins.withType(com.android.build.gradle.BasePlugin).configureEach {
    android {
      compileOptions {
        sourceCompatibility javaTargetVersion
        targetCompatibility javaTargetVersion
      }
    }
  }

  tasks.withType(org.gradle.api.tasks.compile.JavaCompile).configureEach {
    sourceCompatibility = javaTargetVersion
    targetCompatibility = javaTargetVersion
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
    compilerOptions {
      jvmTarget.set(jvmTargetVersion)
      allWarningsAsErrors = true
    }
  }
  if(project.name.startsWith("roborazzi") &&
          project.name != "roborazzi-idea-plugin") {
      tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
          compilerOptions {
              freeCompilerArgs.addAll(
                      "-Xopt-in=com.github.takahirom.roborazzi.InternalRoborazziApi",
                      "-Xopt-in=com.github.takahirom.roborazzi.ExperimentalRoborazziApi",
              )
          }
      }
  }
  plugins.withId('com.vanniktech.maven.publish') {
    project.group = "io.github.takahirom.roborazzi"
    mavenPublishing {
      publishToMavenCentral(com.vanniktech.maven.publish.SonatypeHost.S01)
      signAllPublications()
    }

    plugins.withId('maven-publish') {
      publishing {
        repositories {
          maven {
            name = "LocalMaven"
            url = file("${rootProject.buildDir}/localMaven").toURI().toString()
          }
          def internalUrl = providers.gradleProperty("internalUrl")
          if (internalUrl.isPresent()) {
            maven {
              name = "internal"
              url = internalUrl
              credentials {
                username = providers.gradleProperty("internalUsername").get()
                password = providers.gradleProperty("internalPassword").get()
              }
            }
          }
        }
      }
    }
  }

  configurations.all {
    resolutionStrategy {
      dependencySubstitution {
        substitute(module("io.github.takahirom.roborazzi:roborazzi-compose-preview-scanner-support")).using(project(":roborazzi-compose-preview-scanner-support"))
      }
    }
  }
}

class Topic {
    String name
    String content

    @Override
    String toString() {
        return "Topic(name: $name, content: ...)"
    }
}

def topicsPath = "docs/topics"
def topicsDir = rootProject.file(topicsPath)
def readmeTemplate = rootProject.file("README.template.md")
def readme = rootProject.file("README.md")
// Generate README.md from docs/topics/topic_name.md files by coping
// Insert topics into <topics=name="...">...</topics> by name in README.md
tasks.register("generateReadme") {
    doLast {
        def readmeContent = readmeTemplate.text
        def topicFiles = []
        topicsDir.eachFileRecurse { file ->
            if (file.name.endsWith(".md")) {
                topicFiles.add(file)
            }
        }
        def topics = topicFiles.collect { file ->
            def name = file.name.substring(0, file.name.length() - ".md".length())
            def content = Matcher.quoteReplacement(file.text)
            new Topic(name: name, content: content)
        }
        def newReadmeContent = readmeContent
        println(topics)
        topics.forEach { topic ->
            def pattern = Pattern.compile("<div name=\"topic_${topic.name}\">.*?</div>", Pattern.DOTALL)
            def result = pattern.matcher(newReadmeContent).find()
            println("topic: $topic pattern: $pattern result: $result")

            def generatedComment = "<!-- Generated by $topicsPath/${topic.name}.md. Do not edit this file. -->"
            def newTopicContent = "<div name=\"topic_${topic.name}\">\n\n$generatedComment\n${topic.content}\n<\\/div>"
            newReadmeContent = pattern.matcher(newReadmeContent)
                    .replaceAll(newTopicContent)
        }
        readme.write(newReadmeContent)
    }
}