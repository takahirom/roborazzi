import java.util.regex.Matcher
import java.util.regex.Pattern

plugins {
  id 'com.android.application' version libs.versions.agp apply false
  id 'com.android.library' version libs.versions.agp apply false
  id 'org.jetbrains.kotlin.multiplatform' version libs.versions.kotlin apply false
  id 'org.jetbrains.compose' version "1.4.3" apply false

  id 'org.jetbrains.kotlin.android' version libs.versions.kotlin apply false
  id "com.vanniktech.maven.publish" version libs.versions.mavenPublish apply false
  // Just for Gradle Build, included build will be applied
  id("io.github.takahirom.roborazzi") version "1.0.0" apply false
}

allprojects {
  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
    kotlinOptions {
      freeCompilerArgs += "-Xopt-in=com.github.takahirom.roborazzi.InternalRoborazziApi"
      freeCompilerArgs += "-Xopt-in=com.github.takahirom.roborazzi.ExperimentalRoborazziApi"
    }
  }

  plugins.withId('com.vanniktech.maven.publish') {
    project.group = "io.github.takahirom.roborazzi"
    mavenPublishing {
      publishToMavenCentral(com.vanniktech.maven.publish.SonatypeHost.S01)
      signAllPublications()
    }

    plugins.withId('maven-publish') {
      publishing {
        repositories {
          maven {
            name = "LocalMaven"
            url = file("${rootProject.buildDir}/localMaven").toURI().toString()
          }
          def internalUrl = providers.gradleProperty("internalUrl")
          if (internalUrl.isPresent()) {
            maven {
              name = "internal"
              url = internalUrl
              credentials {
                username = providers.gradleProperty("internalUsername").get()
                password = providers.gradleProperty("internalPassword").get()
              }
            }
          }
        }
      }
    }
  }
}

class Topic {
    String name
    String content

    @Override
    String toString() {
        return "Topic(name: $name, content: ...)"
    }
}

def topicsPath = "docs/topics"
def topicsDir = rootProject.file(topicsPath)
def readmeTemplate = rootProject.file("README.template.md")
def readme = rootProject.file("README.md")
// Generate README.md from docs/topics/topic_name.md files by coping
// Insert topics into <topics=name="...">...</topics> by name in README.md
tasks.register("generateReadme") {
    doLast {
        def readmeContent = readmeTemplate.text
        def topicFiles = []
        topicsDir.eachFileRecurse { file ->
            if (file.name.endsWith(".md")) {
                topicFiles.add(file)
            }
        }
        def topics = topicFiles.collect { file ->
            def name = file.name.substring(0, file.name.length() - ".md".length())
            def content = Matcher.quoteReplacement(file.text)
            new Topic(name: name, content: content)
        }
        def newReadmeContent = readmeContent
        println(topics)
        topics.forEach { topic ->
            def pattern = Pattern.compile("<div name=\"topic_${topic.name}\">.*?</div>", Pattern.DOTALL)
            def result = pattern.matcher(newReadmeContent).find()
            println("topic: $topic pattern: $pattern result: $result")

            def generatedComment = "<!-- Generated by $topicsPath/${topic.name}.md. Do not edit this file. -->"
            def newTopicContent = "<div name=\"topic_${topic.name}\">\n\n$generatedComment\n${topic.content}\n<\\/div>"
            newReadmeContent = pattern.matcher(newReadmeContent)
                    .replaceAll(newTopicContent)
        }
        readme.write(newReadmeContent)
    }
}